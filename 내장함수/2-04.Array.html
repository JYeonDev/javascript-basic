<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <div id="div1"></div>
    <script>
        // toString() - 배열을 하나의 문자열로 만들어준다.
        var fruits = ["Banana", "Orange", "Apple"];
        console.log(fruits.toString());

        
        // join() - 인덱스 사이의 문자를 추가해서 하나의 문자열로 만들어준다.
        console.log(fruits.join(" * "));
        var txt = "Banana";
        txt += "Orange";
        txt += "Apple";


        // push() - 배열을 추가하는 메서드
        var arr = [];
        arr.push("Banana");
        arr.push("Orange");
        arr.push("Apple");

        // document.getElementById("div1").innerHTML = txt;
        document.getElementById("div1").innerHTML = arr.join("<br>");


        // pop() - 배열의 가장 마지막 element를 제거
        // 제거한 element를 리턴해준다.
        var arr2 = fruits.pop();
        console.log(arr2);
        console.log(fruits);


        // push() - 배열의 마지막에 새 element 추가
        fruits.push("Kiwi");
        console.log(fruits);


        // shift() - 배열의 첫 번째 element제거
        // shift()로 제거된 element 반환
        var str = fruits.shift();
        console.log(str);
        console.log(fruits);


        // unshift() - 배열의 첫번째 element 추가
        fruits.unshift("lemon");
        console.log(fruits);
        fruits[0] = "Banana";
        console.log(fruits);
        fruits[fruits.length - 1] = "lemon"
        console.log(fruits);

        
        // splice(parameter1,parameter2,parameter3)
        // parameter1 - 시작인덱스위치
        // parameter2 - 삭제할 element 수
        // parameter - 추가할 배열
        var fruits = ["Banana", "Orange", "Apple"];
        fruits.splice(1,1,"lemon","kiwi");
        console.log(fruits);


        // concat() - 배열을 하나로 합쳐준다.
        var myBoys = ["JongYeon"];
        var myGirls = ["one", "two"];
        var myChildren = myBoys.concat(myGirls);
        console.log(myChildren);

        
        // slice(시작점, 끝점) - 배열의 원하는 부분을 가져온다.
        // 끝점의 인덱스는 해당숫자의 전 인덱스까지 해당한다. ex) slice(1,2) 1인덱스부터 2인덱스전까지
        // 시작인덱스만 입력하면 시작인덱스부터 뒤에 모든 배열요소를 가져온다.
        var fruits2 = fruits.slice(1,2);
        console.log(fruits2);


        // sort() - 오름차순으로 배열을 정렬해준다.
        var fruits = ["Banana", "Orange", "Apple","lemon","kiwi"];
        console.log("과일",fruits.sort());

        var points = [40, 100, 70, 21, 99];
        // console.log(points.sort());
        points.sort(function(a, b){
            if(a > b){
                return 1;
            } else if(a < b) {
                return -1
            } else {
                return 0
            }
        });
        console.log(points);

        points.sort(function(a, b){
            if(a > b){
                return -1;
            } else if(a < b) {
                return 1
            } else {
                return 0
            }
        });
        console.log(points);

        points.sort(function(a, b){
           return a - b;
        });
        console.log(points);

        points.sort(function(a, b){
           return b - a;
        });
        console.log(points);

        var persons = [
            {name: "JY", point:70, city:"서울"},
            {name: "KY", point:60, city:"서울"},
            {name: "LY", point:50, city:"제주"},
            {name: "HY", point:40, city:"서울"}
        ];

        persons.sort(function(a,b){
            if(a.point > b.point){
                return 1;
            } else if(a.point < b.point) {
                return -1;
            } else {
                return 0;
            }
        });

        console.log(persons);

        persons.sort(function(a,b){
            return a.point > b.point ? 1 : a.point < b.point ? -1 : 0;
            // ? 리턴값     : 조건
        });

        console.log(persons);


        // reverse() 배열의 순서를 뒤집는다.
        fruits.reverse();
        console.log(fruits);


        // filter() - 조건의 맞는 배열만 리턴       ★★★★★★ 왕중요
        var pass = persons.filter(function(person){
            return person.point > 50;
        });

        console.log(pass);

        var jeju = persons.filter(function(person){
            return person.city == "제주";
        });

        console.log(jeju);

        
        // reduce()             ★★★★★★ 왕중요
        // reduce 함수에서 첫번째 파라미터는 accumulator(누산기) 누적으로 쌓이는 값
        // 두번째 파라미터는 currentValue(배열 읽으면서 현재 값)    <-보통 두번째 파라미터까지만 씀
        // 세번째 파라미터는 현재 인덱스
        // 네번째 파라미터는 전체 배열
        var arr1 = [1,2,3,4];
        var total = arr1.reduce(function(a, c, i, arr){
            console.log(i, arr);
            return a + c;
        });

        console.log(total);


        // map()                ★★★★★★ 왕중요
        var userList = [
            {firstName: "재석", lastName: "유", email:"yu@gmail.com"},
            {firstName: "종국", lastName: "김", email:"kim@gmail.com"},
            {firstName: "석진", lastName: "지", email:"yang@gmail.com"},
            {firstName: "세찬", lastName: "양", email:"ji@gmail.com"}
        ];

        var userList2 = userList.map(function(user){
            return {fullName: user.lastName + user.firstName,firstName: user.firstName, lastName: user.lastName}//, email: user.email}
        });

        console.log(userList2);
    </script>
</body>
</html>